diff --git a/sage/categories/category_singleton.pyx b/sage/categories/category_singleton.pyx
index cf612f9..b082e70 100644
--- a/sage/categories/category_singleton.pyx
+++ b/sage/categories/category_singleton.pyx
@@ -89,7 +89,7 @@ class Category_singleton(Category):
 
     A *singleton* category is a category whose class takes no
     parameters like ``Fields()`` or ``Rings()``. See also the
-    `Singleton design pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_.
+    `Singleton design pattern <:wikipedia:`Singleton_pattern`>`_.
 
     This is a subclass of :class:`Category`, with a couple
     optimizations for singleton categories.
diff --git a/sage/coding/linear_rank_metric.py b/sage/coding/linear_rank_metric.py
index c06b16a..178f1aa 100644
--- a/sage/coding/linear_rank_metric.py
+++ b/sage/coding/linear_rank_metric.py
@@ -86,7 +86,7 @@ Further references
 ------------------
 
 Read more about
-`rank metric and Gabidulin codes <https://en.wikipedia.org/wiki/Rank_error-correcting_code>`_
+`rank metric and Gabidulin codes <:wikipedia:`Rank_error-correcting_code`>`_
 
 AUTHORS:
 
diff --git a/sage/databases/oeis.py b/sage/databases/oeis.py
index 2018635..00cbb30 100644
--- a/sage/databases/oeis.py
+++ b/sage/databases/oeis.py
@@ -1023,7 +1023,7 @@ class OEISSequence(SageObject, UniqueRepresentation):
         .. TODO::
 
             - ask OEIS to add a keyword telling whether the sequence comes from
-              a power series, e.g. for https://oeis.org/A000182
+              a power series, e.g. for :oeis:`A000182`
             - discover other possible conversions.
 
         EXAMPLES::
diff --git a/sage/graphs/generators/distance_regular.pyx b/sage/graphs/generators/distance_regular.pyx
index e97241c..e8a731b 100644
--- a/sage/graphs/generators/distance_regular.pyx
+++ b/sage/graphs/generators/distance_regular.pyx
@@ -985,7 +985,7 @@ def HalfCube(const int n):
 
     See [BCN1989]_ pp. 264, 265 or [VDKT2016]_ p. 21.
     This construction can be found on
-    https://en.wikipedia.org/wiki/Halved_cube_graph#Equivalent_constructions
+    :wikipedia:`Halved_cube_graph#Equivalent_constructions`
 
     TESTS:
 
diff --git a/sage/knots/knotinfo.py b/sage/knots/knotinfo.py
index facc4ad..527406c 100644
--- a/sage/knots/knotinfo.py
+++ b/sage/knots/knotinfo.py
@@ -42,7 +42,7 @@ Also, note that the braid notation is used according to Sage, even thought in
 the source where it is taken from, the braid generators are assumed to have a
 negative crossing which would be opposite to the convention in Sage (see definition
 3 of `Gittings, T., "Minimum Braids: A Complete Invariant of Knots and Links
-<https://arxiv.org/abs/math/0401051>`__).
+<:arxiv:`math/0401051`>`__).
 
 For different conventions regarding normalization of the polynomial invariants see
 the according documentation of :meth:`KnotInfoBase.homfly_polynomial`,
diff --git a/sage/matrix/matrix_polynomial_dense.pyx b/sage/matrix/matrix_polynomial_dense.pyx
index 566077b..711d575 100644
--- a/sage/matrix/matrix_polynomial_dense.pyx
+++ b/sage/matrix/matrix_polynomial_dense.pyx
@@ -781,7 +781,7 @@ cdef class Matrix_polynomial_dense(Matrix_generic_dense):
             2021), it would be highly beneficial to use conversions and rely on
             polynomials with matrix coefficients when the matrix size is
             "large" and the degree "small", see
-            [https://trac.sagemath.org/ticket/31472#comment:5].
+            [:trac:`ticket/31472#comment:5`].
         """
         if d <= 0:
             raise ValueError("the precision must be positive")
diff --git a/sage/modules/with_basis/invariant.py b/sage/modules/with_basis/invariant.py
index ff4388b..eaf4ce2 100644
--- a/sage/modules/with_basis/invariant.py
+++ b/sage/modules/with_basis/invariant.py
@@ -205,7 +205,7 @@ class FiniteDimensionalInvariantModule(SubmoduleWithBasis):
         Extend when `M` does not have a basis and `S` is a permutation
         group using:
 
-        - https://arxiv.org/abs/0812.3082
+        - :arxiv:`0812.3082`
         - https://www.dmtcs.org/pdfpapers/dmAA0123.pdf
     """
     def __init__(self, M, S, action=operator.mul, side='left', *args, **kwargs):
diff --git a/sage/rings/function_field/order.py b/sage/rings/function_field/order.py
index ebe610b..7b0841e 100644
--- a/sage/rings/function_field/order.py
+++ b/sage/rings/function_field/order.py
@@ -1772,7 +1772,7 @@ class FunctionFieldMaximalOrder_polymod(FunctionFieldMaximalOrder):
         finite-dimensional algebra, a construct for which we do
         support primary decomposition.
 
-        See https://trac.sagemath.org/attachment/ticket/28094/decomposition.pdf
+        See :trac:`attachment/ticket/28094/decomposition.pdf`
 
         .. TODO::
 
diff --git a/sage/sat/solvers/satsolver.pyx b/sage/sat/solvers/satsolver.pyx
index 3f7b722..352f0dd 100644
--- a/sage/sat/solvers/satsolver.pyx
+++ b/sage/sat/solvers/satsolver.pyx
@@ -316,7 +316,7 @@ def SAT(solver=None, *args, **kwds):
     Return a :class:`SatSolver` instance.
 
     Through this class, one can define and solve `SAT
-    <https://en.wikipedia.org/wiki/Boolean_satisfiability_problem>`__ problems.
+    <:wikipedia:`Boolean_satisfiability_problem`>`__ problems.
 
     INPUT:
 
